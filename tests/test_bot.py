from __future__ import annotations

from unittest.mock import AsyncMock, MagicMock, patch

from discord import Attachment, Message

import pytest

from sandbox_agent.bot import SandboxAgent
from sandbox_agent.utils.file_operations import create_temp_directory


@pytest.fixture
def sandbox_agent():
    return SandboxAgent()

@pytest.mark.asyncio
async def test_process_attachments(sandbox_agent):
    message = AsyncMock(spec=Message)
    attachment = AsyncMock(spec=Attachment)
    attachment.filename = "test_file.txt"
    attachment.url = "http://example.com/test_file.txt"
    message.attachments = [attachment]

    with patch("aiohttp.ClientSession.get") as mock_get, \
         patch("builtins.open", create=True) as mock_open, \
         patch("sandbox_agent.utils.file_operations.create_temp_directory", return_value="/tmp/test_dir"):
        mock_response = AsyncMock()
        mock_response.status = 200
        mock_response.read.return_value = b"test content"
        mock_get.return_value.__aenter__.return_value = mock_response

        await sandbox_agent.process_attachments(message)

        mock_get.assert_called_once_with("http://example.com/test_file.txt")
        mock_open.assert_called_once_with("/tmp/test_dir/test_file.txt", "wb")
        mock_open.return_value.__enter__().write.assert_called_once_with(b"test content")

@pytest.mark.skip(reason="generated by cursor but not yet ready")
@pytest.mark.flaky
@pytest.mark.asyncio
async def test_check_for_attachments_tenor_gif(sandbox_agent):
    message = MagicMock(spec=Message)
    message.content = "Check out this GIF https://tenor.com/view/funny-cat-dancing-gif-12345"
    message.author.display_name = "TestUser"

    result = await sandbox_agent.check_for_attachments(message)
    expected = "Check out this GIF [TestUser posts an animated funny cat dancing]"
    assert result == expected

@pytest.mark.asyncio
async def test_check_for_attachments_image_url(sandbox_agent):
    message = MagicMock(spec=Message)
    message.content = "https://example.com/image.jpg"

    with patch.object(sandbox_agent, "process_image") as mock_process_image:
        result = await sandbox_agent.check_for_attachments(message)

        assert result == "https://example.com/image.jpg"
        mock_process_image.assert_called_once_with("https://example.com/image.jpg")

@pytest.mark.asyncio
async def test_check_for_attachments_attached_image(sandbox_agent):
    message = MagicMock(spec=Message)
    message.content = "Check out this image"
    attachment = MagicMock(spec=Attachment)
    attachment.url = "http://example.com/attached_image.jpg"
    message.attachments = [attachment]

    with patch.object(sandbox_agent, "process_image") as mock_process_image:
        result = await sandbox_agent.check_for_attachments(message)

        assert result == "Check out this image"
        mock_process_image.assert_called_once_with("http://example.com/attached_image.jpg")

@pytest.mark.skip(reason="generated by cursor but not yet ready")
@pytest.mark.flaky
@pytest.mark.asyncio
async def test_process_image(sandbox_agent):
    url = "http://example.com/image.jpg"

    with patch("sandbox_agent.utils.file_operations.download_image") as mock_download, \
         patch("PIL.Image.open") as mock_image_open:
        mock_response = MagicMock()
        mock_response.content = b"fake image data"
        mock_download.return_value = mock_response
        mock_image = MagicMock()
        mock_image_open.return_value.convert.return_value = mock_image

        await sandbox_agent.process_image(url)

        mock_download.assert_called_once_with(url)
        mock_image_open.assert_called_once()
        mock_image.convert.assert_called_once_with("RGB")

# Add more test cases for other methods in the SandboxAgent class
import pytest
from unittest.mock import AsyncMock, MagicMock, patch
from discord import Message, Attachment, File
from io import BytesIO
from PIL import Image

from sandbox_agent.bot import SandboxAgent

@pytest.fixture
def bot():
    return SandboxAgent()

@pytest.mark.asyncio
async def test_process_attachments(bot):
    mock_message = AsyncMock(spec=Message)
    mock_attachment = AsyncMock(spec=Attachment)
    mock_attachment.url = "http://example.com/test.jpg"
    mock_attachment.filename = "test.jpg"
    mock_message.attachments = [mock_attachment]

    with patch("aiohttp.ClientSession.get") as mock_get, \
         patch("builtins.open", create=True) as mock_open, \
         patch("os.makedirs") as mock_makedirs:
        mock_get.return_value.__aenter__.return_value.status = 200
        mock_get.return_value.__aenter__.return_value.read.return_value = b"fake image data"

        await bot.process_attachments(mock_message)

        mock_makedirs.assert_called()
        mock_open.assert_called()
        mock_get.assert_called_with("http://example.com/test.jpg")

@pytest.mark.asyncio
async def test_check_for_attachments_tenor_gif(bot):
    mock_message = MagicMock(spec=Message)
    mock_message.content = "Check out this GIF https://tenor.com/view/funny-cat-dancing-gif-12345"
    mock_message.author.display_name = "TestUser"

    result = await bot.check_for_attachments(mock_message)
    expected = "Check out this GIF  [TestUser posts an animated funny cat dancing]"
    assert result == expected

@pytest.mark.asyncio
async def test_check_for_attachments_image_url(bot):
    mock_message = MagicMock(spec=Message)
    mock_message.content = "Look at this image http://example.com/image.jpg"

    with patch.object(bot, "process_image") as mock_process_image:
        await bot.check_for_attachments(mock_message)
        mock_process_image.assert_called_with("http://example.com/image.jpg")

@pytest.mark.asyncio
async def test_process_image(bot):
    url = "http://example.com/test.jpg"
    mock_response = MagicMock()
    mock_response.content = b"fake image data"

    with patch("sandbox_agent.utils.file_operations.download_image", return_value=mock_response) as mock_download, \
         patch("PIL.Image.open") as mock_image_open:
        mock_image = MagicMock(spec=Image.Image)
        mock_image_open.return_value.convert.return_value = mock_image

        await bot.process_image(url)

        mock_download.assert_called_with(url)
        mock_image_open.assert_called()
        mock_image.convert.assert_called_with("RGB")

@pytest.mark.asyncio
async def test_on_message_bot_message(bot):
    mock_message = AsyncMock(spec=Message)
    mock_message.author.bot = True
    
    await bot.on_message(mock_message)
    
    mock_message.channel.send.assert_not_called()

@pytest.mark.asyncio
async def test_on_message_percent_message(bot):
    mock_message = AsyncMock(spec=Message)
    mock_message.author.bot = False
    mock_message.content = "%some command"
    
    await bot.on_message(mock_message)
    
    mock_message.channel.send.assert_not_called()

@pytest.mark.asyncio
async def test_on_message_valid_message(bot):
    mock_message = AsyncMock(spec=Message)
    mock_message.author.bot = False
    mock_message.content = "Hello, bot!"
    
    with patch.object(bot, "process_attachments") as mock_process_attachments, \
         patch.object(bot, "process_commands") as mock_process_commands:
        await bot.on_message(mock_message)
        
        mock_process_attachments.assert_called_once_with(mock_message)
        mock_process_commands.assert_called_once_with(mock_message)

@pytest.mark.asyncio
async def test_chat_command(bot):
    ctx = AsyncMock()
    message = "Hello, bot!"
    
    mock_response = MagicMock()
    mock_response.generations = [[MagicMock(text="Bot response")]]
    
    with patch.object(bot.chat_model, "agenerate", return_value=mock_response) as mock_agenerate:
        await bot.chat(ctx, message=message)
        
        mock_agenerate.assert_called_once_with([message])
        ctx.send.assert_called_once_with("Bot response")
