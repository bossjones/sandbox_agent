"""
This type stub file was generated by pyright.
"""

import concurrent.futures
from types import TracebackType
from typing import Any, AsyncContextManager, Callable, ContextManager, List, Literal, Mapping, Optional, Sequence, Type, TypeVar, Union
from langchain_core.callbacks import AsyncParentRunManager, ParentRunManager
from langchain_core.runnables import RunnableConfig
from typing_extensions import ParamSpec, Self
from langgraph.channels.base import BaseChannel
from langgraph.checkpoint.base import BaseCheckpointSaver, ChannelVersions, Checkpoint, CheckpointMetadata, PendingWrite
from langgraph.managed.base import ManagedValueMapping, ManagedValueSpec
from langgraph.pregel.algo import GetNextVersion
from langgraph.pregel.executor import Submit
from langgraph.pregel.read import PregelNode
from langgraph.store.base import BaseStore
from langgraph.types import All, LoopProtocol, PregelExecutableTask, StreamProtocol

V = TypeVar("V")
P = ParamSpec("P")
StreamChunk = tuple[tuple[str, ...], str, Any]
INPUT_DONE = ...
INPUT_RESUMING = ...
SPECIAL_CHANNELS = ...
def DuplexStream(*streams: StreamProtocol) -> StreamProtocol:
    ...

class PregelLoop(LoopProtocol):
    input: Optional[Any]
    checkpointer: Optional[BaseCheckpointSaver]
    nodes: Mapping[str, PregelNode]
    specs: Mapping[str, Union[BaseChannel, ManagedValueSpec]]
    output_keys: Union[str, Sequence[str]]
    stream_keys: Union[str, Sequence[str]]
    skip_done_tasks: bool
    is_nested: bool
    checkpointer_get_next_version: GetNextVersion
    checkpointer_put_writes: Optional[Callable[[RunnableConfig, Sequence[tuple[str, Any]], str], Any]]
    _checkpointer_put_after_previous: Optional[Callable[[Optional[concurrent.futures.Future], RunnableConfig, Sequence[tuple[str, Any]], str, ChannelVersions], Any,]]
    submit: Submit
    channels: Mapping[str, BaseChannel]
    managed: ManagedValueMapping
    checkpoint: Checkpoint
    checkpoint_ns: tuple[str, ...]
    checkpoint_config: RunnableConfig
    checkpoint_metadata: CheckpointMetadata
    checkpoint_pending_writes: List[PendingWrite]
    checkpoint_previous_versions: dict[str, Union[str, float, int]]
    prev_checkpoint_config: Optional[RunnableConfig]
    status: Literal["pending", "done", "interrupt_before", "interrupt_after", "out_of_steps"]
    tasks: dict[str, PregelExecutableTask]
    output: Union[None, dict[str, Any], Any] = ...
    def __init__(self, input: Optional[Any], *, stream: Optional[StreamProtocol], config: RunnableConfig, store: Optional[BaseStore], checkpointer: Optional[BaseCheckpointSaver], nodes: Mapping[str, PregelNode], specs: Mapping[str, Union[BaseChannel, ManagedValueSpec]], output_keys: Union[str, Sequence[str]], stream_keys: Union[str, Sequence[str]], check_subgraphs: bool = ..., debug: bool = ...) -> None:
        ...

    def put_writes(self, task_id: str, writes: Sequence[tuple[str, Any]]) -> None:
        """Put writes for a task, to be read by the next tick."""
        ...

    def tick(self, *, input_keys: Union[str, Sequence[str]], interrupt_after: Union[All, Sequence[str]] = ..., interrupt_before: Union[All, Sequence[str]] = ..., manager: Union[None, AsyncParentRunManager, ParentRunManager] = ...) -> bool:
        """Execute a single iteration of the Pregel loop.
        Returns True if more iterations are needed."""
        ...



class SyncPregelLoop(PregelLoop, ContextManager):
    def __init__(self, input: Optional[Any], *, stream: Optional[StreamProtocol], config: RunnableConfig, store: Optional[BaseStore], checkpointer: Optional[BaseCheckpointSaver], nodes: Mapping[str, PregelNode], specs: Mapping[str, Union[BaseChannel, ManagedValueSpec]], output_keys: Union[str, Sequence[str]] = ..., stream_keys: Union[str, Sequence[str]] = ..., check_subgraphs: bool = ..., debug: bool = ...) -> None:
        ...

    def __enter__(self) -> Self:
        ...

    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]) -> Optional[bool]:
        ...



class AsyncPregelLoop(PregelLoop, AsyncContextManager):
    def __init__(self, input: Optional[Any], *, stream: Optional[StreamProtocol], config: RunnableConfig, store: Optional[BaseStore], checkpointer: Optional[BaseCheckpointSaver], nodes: Mapping[str, PregelNode], specs: Mapping[str, Union[BaseChannel, ManagedValueSpec]], output_keys: Union[str, Sequence[str]] = ..., stream_keys: Union[str, Sequence[str]] = ..., check_subgraphs: bool = ..., debug: bool = ...) -> None:
        ...

    async def __aenter__(self) -> Self:
        ...

    async def __aexit__(self, exc_type: Optional[Type[BaseException]], exc_value: Optional[BaseException], traceback: Optional[TracebackType]) -> Optional[bool]:
        ...
