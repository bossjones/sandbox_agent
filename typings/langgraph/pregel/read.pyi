"""
This type stub file was generated by pyright.
"""

from functools import cached_property
from typing import Any, AsyncIterator, Callable, Iterator, Mapping, Optional, Sequence, Union
from langchain_core.runnables import Runnable, RunnableConfig, RunnablePassthrough, RunnableSerializable
from langchain_core.runnables.base import Input, Other
from langchain_core.runnables.utils import ConfigurableFieldSpec
from langgraph.pregel.retry import RetryPolicy
from langgraph.utils.runnable import RunnableCallable

READ_TYPE = Callable[[Union[str, Sequence[str]], bool], Union[Any, dict[str, Any]]]
class ChannelRead(RunnableCallable):
    """Implements the logic for reading state from CONFIG_KEY_READ.
    Usable both as a runnable as well as a static method to call imperatively."""
    channel: Union[str, list[str]]
    fresh: bool = ...
    mapper: Optional[Callable[[Any], Any]] = ...
    @property
    def config_specs(self) -> list[ConfigurableFieldSpec]:
        ...

    def __init__(self, channel: Union[str, list[str]], *, fresh: bool = ..., mapper: Optional[Callable[[Any], Any]] = ..., tags: Optional[list[str]] = ...) -> None:
        ...

    def get_name(self, suffix: Optional[str] = ..., *, name: Optional[str] = ...) -> str:
        ...

    @staticmethod
    def do_read(config: RunnableConfig, *, select: Union[str, list[str]], fresh: bool = ..., mapper: Optional[Callable[[Any], Any]] = ...) -> Any:
        ...



DEFAULT_BOUND: RunnablePassthrough = ...
class PregelNode(Runnable):
    """A node in a Pregel graph. This won't be invoked as a runnable by the graph
    itself, but instead acts as a container for the components necessary to make
    a PregelExecutableTask for a node."""
    channels: Union[list[str], Mapping[str, str]]
    triggers: list[str]
    mapper: Optional[Callable[[Any], Any]]
    writers: list[Runnable]
    bound: Runnable[Any, Any]
    retry_policy: Optional[RetryPolicy]
    tags: Optional[Sequence[str]]
    metadata: Optional[Mapping[str, Any]]
    def __init__(self, *, channels: Union[list[str], Mapping[str, str]], triggers: Sequence[str], mapper: Optional[Callable[[Any], Any]] = ..., writers: Optional[list[Runnable]] = ..., tags: Optional[list[str]] = ..., metadata: Optional[Mapping[str, Any]] = ..., bound: Optional[Runnable[Any, Any]] = ..., retry_policy: Optional[RetryPolicy] = ...) -> None:
        ...

    def copy(self, update: dict[str, Any]) -> PregelNode:
        ...

    @cached_property
    def flat_writers(self) -> list[Runnable]:
        """Get writers with optimizations applied. Dedupes consecutive ChannelWrites."""
        ...

    @cached_property
    def node(self) -> Optional[Runnable[Any, Any]]:
        """Get a runnable that combines `bound` and `writers`."""
        ...

    def join(self, channels: Sequence[str]) -> PregelNode:
        ...

    def __or__(self, other: Union[Runnable[Any, Other], Callable[[Any], Other], Mapping[str, Runnable[Any, Other] | Callable[[Any], Other]],]) -> PregelNode:
        ...

    def pipe(self, *others: Runnable[Any, Other] | Callable[[Any], Other], name: Optional[str] = ...) -> RunnableSerializable[Any, Other]:
        ...

    def __ror__(self, other: Union[Runnable[Other, Any], Callable[[Any], Other], Mapping[str, Union[Runnable[Other, Any], Callable[[Other], Any]]],]) -> RunnableSerializable:
        ...

    def invoke(self, input: Input, config: Optional[RunnableConfig] = ..., **kwargs: Optional[Any]) -> Any:
        ...

    async def ainvoke(self, input: Input, config: Optional[RunnableConfig] = ..., **kwargs: Optional[Any]) -> Any:
        ...

    def stream(self, input: Input, config: Optional[RunnableConfig] = ..., **kwargs: Optional[Any]) -> Iterator[Any]:
        ...

    async def astream(self, input: Input, config: Optional[RunnableConfig] = ..., **kwargs: Optional[Any]) -> AsyncIterator[Any]:
        ...
