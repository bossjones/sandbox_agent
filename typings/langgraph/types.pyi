"""
This type stub file was generated by pyright.
"""

from collections import deque
from dataclasses import dataclass
from typing import Any, Callable, Literal, NamedTuple, Optional, Sequence, TYPE_CHECKING, Type, Union
from langchain_core.runnables import Runnable, RunnableConfig
from langgraph.checkpoint.base import BaseCheckpointSaver, CheckpointMetadata
from langgraph.store.base import BaseStore

if TYPE_CHECKING:
    ...
All = Literal["*"]
Checkpointer = Union[None, Literal[False], BaseCheckpointSaver]
StreamMode = Literal["values", "updates", "debug", "messages", "custom"]
StreamWriter = Callable[[Any], None]
def default_retry_on(exc: Exception) -> bool:
    ...

class RetryPolicy(NamedTuple):
    """Configuration for retrying nodes."""
    initial_interval: float = ...
    backoff_factor: float = ...
    max_interval: float = ...
    max_attempts: int = ...
    jitter: bool = ...
    retry_on: Union[Type[Exception], Sequence[Type[Exception]], Callable[[Exception], bool]] = ...


class CachePolicy(NamedTuple):
    """Configuration for caching nodes."""
    ...


@dataclass
class Interrupt:
    value: Any
    when: Literal["during"] = ...


class PregelTask(NamedTuple):
    id: str
    name: str
    path: tuple[Union[str, int], ...]
    error: Optional[Exception] = ...
    interrupts: tuple[Interrupt, ...] = ...
    state: Union[None, RunnableConfig, StateSnapshot] = ...
    result: Optional[dict[str, Any]] = ...


class PregelExecutableTask(NamedTuple):
    name: str
    input: Any
    proc: Runnable
    writes: deque[tuple[str, Any]]
    config: RunnableConfig
    triggers: list[str]
    retry_policy: Optional[RetryPolicy]
    cache_policy: Optional[CachePolicy]
    id: str
    path: tuple[Union[str, int], ...]
    scheduled: bool = ...


class StateSnapshot(NamedTuple):
    """Snapshot of the state of the graph at the beginning of a step."""
    values: Union[dict[str, Any], Any]
    next: tuple[str, ...]
    config: RunnableConfig
    metadata: Optional[CheckpointMetadata]
    created_at: Optional[str]
    parent_config: Optional[RunnableConfig]
    tasks: tuple[PregelTask, ...]
    ...


class Send:
    """A message or packet to send to a specific node in the graph.

    The `Send` class is used within a `StateGraph`'s conditional edges to
    dynamically invoke a node with a custom state at the next step.

    Importantly, the sent state can differ from the core graph's state,
    allowing for flexible and dynamic workflow management.

    One such example is a "map-reduce" workflow where your graph invokes
    the same node multiple times in parallel with different states,
    before aggregating the results back into the main graph's state.

    Attributes:
        node (str): The name of the target node to send the message to.
        arg (Any): The state or message to send to the target node.

    Examples:
        >>> from typing import Annotated
        >>> import operator
        >>> class OverallState(TypedDict):
        ...     subjects: list[str]
        ...     jokes: Annotated[list[str], operator.add]
        ...
        >>> from langgraph.types import Send
        >>> from langgraph.graph import END, START
        >>> def continue_to_jokes(state: OverallState):
        ...     return [Send("generate_joke", {"subject": s}) for s in state['subjects']]
        ...
        >>> from langgraph.graph import StateGraph
        >>> builder = StateGraph(OverallState)
        >>> builder.add_node("generate_joke", lambda state: {"jokes": [f"Joke about {state['subject']}"]})
        >>> builder.add_conditional_edges(START, continue_to_jokes)
        >>> builder.add_edge("generate_joke", END)
        >>> graph = builder.compile()
        >>>
        >>> # Invoking with two subjects results in a generated joke for each
        >>> graph.invoke({"subjects": ["cats", "dogs"]})
        {'subjects': ['cats', 'dogs'], 'jokes': ['Joke about cats', 'Joke about dogs']}
    """
    __slots__ = ...
    node: str
    arg: Any
    def __init__(self, /, node: str, arg: Any) -> None:
        """
        Initialize a new instance of the Send class.

        Args:
            node (str): The name of the target node to send the message to.
            arg (Any): The state or message to send to the target node.
        """
        ...

    def __hash__(self) -> int:
        ...

    def __repr__(self) -> str:
        ...

    def __eq__(self, value: object) -> bool:
        ...



StreamChunk = tuple[tuple[str, ...], str, Any]
class StreamProtocol:
    __slots__ = ...
    modes: set[StreamMode]
    __call__: Callable[[StreamChunk], None]
    def __init__(self, __call__: Callable[[StreamChunk], None], modes: set[StreamMode]) -> None:
        ...



class LoopProtocol:
    config: RunnableConfig
    store: Optional[BaseStore]
    stream: Optional[StreamProtocol]
    step: int
    stop: int
    def __init__(self, *, step: int, stop: int, config: RunnableConfig, store: Optional[BaseStore] = ..., stream: Optional[StreamProtocol] = ...) -> None:
        ...
