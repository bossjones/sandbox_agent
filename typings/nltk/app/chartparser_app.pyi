"""
This type stub file was generated by pyright.
"""

from nltk.draw.util import ColorizedList
from nltk.parse.chart import BottomUpPredictCombineRule, BottomUpPredictRule, SingleEdgeFundamentalRule, TopDownPredictRule

"""
A graphical tool for exploring chart parsing.

Chart parsing is a flexible parsing algorithm that uses a data
structure called a "chart" to record hypotheses about syntactic
constituents.  Each hypothesis is represented by a single "edge" on
the chart.  A set of "chart rules" determine when new edges can be
added to the chart.  This set of rules controls the overall behavior
of the parser (e.g. whether it parses top-down or bottom-up).

The chart parsing tool demonstrates the process of parsing a single
sentence, with a given grammar and lexicon.  Its display is divided
into three sections: the bottom section displays the chart; the middle
section displays the sentence; and the top section displays the
partial syntax tree corresponding to the selected edge.  Buttons along
the bottom of the window are used to control the execution of the
algorithm.

The chart parsing tool allows for flexible control of the parsing
algorithm.  At each step of the algorithm, you can select which rule
or strategy you wish to apply.  This allows you to experiment with
mixing different strategies (e.g. top-down and bottom-up).  You can
exercise fine-grained control over the algorithm by selecting which
edge you wish to apply a rule to.
"""
class EdgeList(ColorizedList):
    ARROW = ...


class ChartMatrixView:
    """
    A view of a chart that displays the contents of the corresponding matrix.
    """
    def __init__(self, parent, chart, toplevel=..., title=..., show_numedges=...) -> None:
        ...

    def destroy(self, *e): # -> None:
        ...

    def set_chart(self, chart): # -> None:
        ...

    def update(self): # -> None:
        ...

    def activate(self): # -> None:
        ...

    def inactivate(self): # -> None:
        ...

    def add_callback(self, event, func): # -> None:
        ...

    def remove_callback(self, event, func=...): # -> None:
        ...

    def select_cell(self, i, j): # -> None:
        ...

    def deselect_cell(self): # -> None:
        ...

    def view_edge(self, edge): # -> None:
        ...

    def mark_edge(self, edge): # -> None:
        ...

    def unmark_edge(self, edge=...): # -> None:
        ...

    def markonly_edge(self, edge): # -> None:
        ...

    def draw(self): # -> None:
        ...

    def pack(self, *args, **kwargs): # -> None:
        ...



class ChartResultsView:
    def __init__(self, parent, chart, grammar, toplevel=...) -> None:
        ...

    def update(self, edge=...): # -> None:
        ...

    def print_all(self, *e): # -> None:
        ...

    def print_selection(self, *e): # -> None:
        ...

    def clear(self): # -> None:
        ...

    def set_chart(self, chart): # -> None:
        ...

    def set_grammar(self, grammar): # -> None:
        ...

    def destroy(self, *e): # -> None:
        ...

    def pack(self, *args, **kwargs): # -> None:
        ...



class ChartComparer:
    """

    :ivar _root: The root window

    :ivar _charts: A dictionary mapping names to charts.  When
        charts are loaded, they are added to this dictionary.

    :ivar _left_chart: The left ``Chart``.
    :ivar _left_name: The name ``_left_chart`` (derived from filename)
    :ivar _left_matrix: The ``ChartMatrixView`` for ``_left_chart``
    :ivar _left_selector: The drop-down ``MutableOptionsMenu`` used
          to select ``_left_chart``.

    :ivar _right_chart: The right ``Chart``.
    :ivar _right_name: The name ``_right_chart`` (derived from filename)
    :ivar _right_matrix: The ``ChartMatrixView`` for ``_right_chart``
    :ivar _right_selector: The drop-down ``MutableOptionsMenu`` used
          to select ``_right_chart``.

    :ivar _out_chart: The out ``Chart``.
    :ivar _out_name: The name ``_out_chart`` (derived from filename)
    :ivar _out_matrix: The ``ChartMatrixView`` for ``_out_chart``
    :ivar _out_label: The label for ``_out_chart``.

    :ivar _op_label: A Label containing the most recent operation.
    """
    _OPSYMBOL = ...
    def __init__(self, *chart_filenames) -> None:
        ...

    def destroy(self, *e): # -> None:
        ...

    def mainloop(self, *args, **kwargs): # -> None:
        ...

    CHART_FILE_TYPES = ...
    def save_chart_dialog(self, *args): # -> None:
        ...

    def load_chart_dialog(self, *args): # -> None:
        ...

    def load_chart(self, filename): # -> None:
        ...

    def select_edge(self, edge): # -> None:
        ...

    def select_cell(self, i, j): # -> None:
        ...



class ChartView:
    """
    A component for viewing charts.  This is used by ``ChartParserApp`` to
    allow students to interactively experiment with various chart
    parsing techniques.  It is also used by ``Chart.draw()``.

    :ivar _chart: The chart that we are giving a view of.  This chart
       may be modified; after it is modified, you should call
       ``update``.
    :ivar _sentence: The list of tokens that the chart spans.

    :ivar _root: The root window.
    :ivar _chart_canvas: The canvas we're using to display the chart
        itself.
    :ivar _tree_canvas: The canvas we're using to display the tree
        that each edge spans.  May be None, if we're not displaying
        trees.
    :ivar _sentence_canvas: The canvas we're using to display the sentence
        text.  May be None, if we're not displaying the sentence text.
    :ivar _edgetags: A dictionary mapping from edges to the tags of
        the canvas elements (lines, etc) used to display that edge.
        The values of this dictionary have the form
        ``(linetag, rhstag1, dottag, rhstag2, lhstag)``.
    :ivar _treetags: A list of all the tags that make up the tree;
        used to erase the tree (without erasing the loclines).
    :ivar _chart_height: The height of the chart canvas.
    :ivar _sentence_height: The height of the sentence canvas.
    :ivar _tree_height: The height of the tree

    :ivar _text_height: The height of a text string (in the normal
        font).

    :ivar _edgelevels: A list of edges at each level of the chart (the
        top level is the 0th element).  This list is used to remember
        where edges should be drawn; and to make sure that no edges
        are overlapping on the chart view.

    :ivar _unitsize: Pixel size of one unit (from the location).  This
       is determined by the span of the chart's location, and the
       width of the chart display canvas.

    :ivar _fontsize: The current font size

    :ivar _marks: A dictionary from edges to marks.  Marks are
        strings, specifying colors (e.g. 'green').
    """
    _LEAF_SPACING = ...
    _MARGIN = ...
    _TREE_LEVEL_SIZE = ...
    _CHART_LEVEL_SIZE = ...
    def __init__(self, chart, root=..., **kw) -> None:
        """
        Construct a new ``Chart`` display.
        """
        ...

    def scroll_up(self, *e): # -> None:
        ...

    def scroll_down(self, *e): # -> None:
        ...

    def page_up(self, *e): # -> None:
        ...

    def page_down(self, *e): # -> None:
        ...

    def set_font_size(self, size): # -> None:
        ...

    def get_font_size(self):
        ...

    def update(self, chart=...): # -> None:
        """
        Draw any edges that have not been drawn.  This is typically
        called when a after modifies the canvas that a CanvasView is
        displaying.  ``update`` will cause any edges that have been
        added to the chart to be drawn.

        If update is given a ``chart`` argument, then it will replace
        the current chart with the given chart.
        """
        ...

    def view_edge(self, edge): # -> None:
        ...

    def mark_edge(self, edge, mark=...): # -> None:
        """
        Mark an edge
        """
        ...

    def unmark_edge(self, edge=...): # -> None:
        """
        Unmark an edge (or all edges)
        """
        ...

    def markonly_edge(self, edge, mark=...): # -> None:
        ...

    def erase_tree(self): # -> None:
        ...

    def draw_tree(self, edge=...): # -> None:
        ...

    def cycle_tree(self): # -> None:
        ...

    def draw(self): # -> None:
        """
        Draw everything (from scratch).
        """
        ...

    def add_callback(self, event, func): # -> None:
        ...

    def remove_callback(self, event, func=...): # -> None:
        ...



class EdgeRule:
    """
    To create an edge rule, make an empty base class that uses
    EdgeRule as the first base class, and the basic rule as the
    second base class.  (Order matters!)
    """
    def __init__(self, edge) -> None:
        ...

    def apply(self, chart, grammar, *edges): # -> Generator[Any, Any, None]:
        ...

    def __str__(self) -> str:
        ...



class TopDownPredictEdgeRule(EdgeRule, TopDownPredictRule):
    ...


class BottomUpEdgeRule(EdgeRule, BottomUpPredictRule):
    ...


class BottomUpLeftCornerEdgeRule(EdgeRule, BottomUpPredictCombineRule):
    ...


class FundamentalEdgeRule(EdgeRule, SingleEdgeFundamentalRule):
    ...


class ChartParserApp:
    def __init__(self, grammar, tokens, title=...) -> None:
        ...

    def destroy(self, *args): # -> None:
        ...

    def mainloop(self, *args, **kwargs): # -> None:
        """
        Enter the Tkinter mainloop.  This function must be called if
        this demo is created from a non-interactive program (e.g.
        from a secript); otherwise, the demo will close as soon as
        the script completes.
        """
        ...

    def help(self, *e): # -> None:
        ...

    def about(self, *e): # -> None:
        ...

    CHART_FILE_TYPES = ...
    GRAMMAR_FILE_TYPES = ...
    def load_chart(self, *args): # -> None:
        "Load a chart from a pickle file"
        ...

    def save_chart(self, *args): # -> None:
        "Save a chart to a pickle file"
        ...

    def load_grammar(self, *args): # -> None:
        "Load a grammar from a pickle file"
        ...

    def save_grammar(self, *args): # -> None:
        ...

    def reset(self, *args): # -> None:
        ...

    def edit_grammar(self, *e): # -> None:
        ...

    def set_grammar(self, grammar): # -> None:
        ...

    def edit_sentence(self, *e): # -> None:
        ...

    def set_sentence(self, sentence): # -> None:
        ...

    def view_matrix(self, *e): # -> None:
        ...

    def view_results(self, *e): # -> None:
        ...

    def resize(self): # -> None:
        ...

    def set_font_size(self, size): # -> None:
        ...

    def get_font_size(self): # -> int:
        ...

    def apply_strategy(self, strategy, edge_strategy=...): # -> None:
        ...

    _TD_INIT = ...
    _TD_PREDICT = ...
    _BU_RULE = ...
    _BU_LC_RULE = ...
    _FUNDAMENTAL = ...
    _TD_STRATEGY = ...
    _BU_STRATEGY = ...
    _BU_LC_STRATEGY = ...
    def top_down_init(self, *e): # -> None:
        ...

    def top_down_predict(self, *e): # -> None:
        ...

    def bottom_up(self, *e): # -> None:
        ...

    def bottom_up_leftcorner(self, *e): # -> None:
        ...

    def fundamental(self, *e): # -> None:
        ...

    def bottom_up_strategy(self, *e): # -> None:
        ...

    def bottom_up_leftcorner_strategy(self, *e): # -> None:
        ...

    def top_down_strategy(self, *e): # -> None:
        ...



def app(): # -> None:
    ...

if __name__ == "__main__":
    ...
__all__ = ["app"]
