"""
This type stub file was generated by pyright.
"""

from nltk.sem.drt import DrtParser

"""
An interface to Boxer.

This interface relies on the latest version of the development (subversion) version of
C&C and Boxer.

Usage
=====

Set the environment variable CANDC to the bin directory of your CandC installation.
The models directory should be in the CandC root directory.
For example::

    /path/to/candc/
    bin/
        candc
        boxer
    models/
        boxer/
"""
class Boxer:
    """
    This class is an interface to Johan Bos's program Boxer, a wide-coverage
    semantic parser that produces Discourse Representation Structures (DRSs).
    """
    def __init__(self, boxer_drs_interpreter=..., elimeq=..., bin_dir=..., verbose=..., resolve=...) -> None:
        """
        :param boxer_drs_interpreter: A class that converts from the
            ``AbstractBoxerDrs`` object hierarchy to a different object.  The
            default is ``NltkDrtBoxerDrsInterpreter``, which converts to the NLTK
            DRT hierarchy.
        :param elimeq: When set to true, Boxer removes all equalities from the
            DRSs and discourse referents standing in the equality relation are
            unified, but only if this can be done in a meaning-preserving manner.
        :param resolve: When set to true, Boxer will resolve all anaphoric DRSs and perform merge-reduction.
            Resolution follows Van der Sandt's theory of binding and accommodation.
        """
        ...

    def set_bin_dir(self, bin_dir, verbose=...): # -> None:
        ...

    def interpret(self, input, discourse_id=..., question=..., verbose=...):
        """
        Use Boxer to give a first order representation.

        :param input: str Input sentence to parse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_id: str An identifier to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """
        ...

    def interpret_multi(self, input, discourse_id=..., question=..., verbose=...):
        """
        Use Boxer to give a first order representation.

        :param input: list of str Input sentences to parse as a single discourse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_id: str An identifier to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """
        ...

    def interpret_sents(self, inputs, discourse_ids=..., question=..., verbose=...): # -> list:
        """
        Use Boxer to give a first order representation.

        :param inputs: list of str Input sentences to parse as individual discourses
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_ids: list of str Identifiers to be inserted to each occurrence-indexed predicate.
        :return: list of ``drt.DrtExpression``
        """
        ...

    def interpret_multi_sents(self, inputs, discourse_ids=..., question=..., verbose=...): # -> list:
        """
        Use Boxer to give a first order representation.

        :param inputs: list of list of str Input discourses to parse
        :param occur_index: bool Should predicates be occurrence indexed?
        :param discourse_ids: list of str Identifiers to be inserted to each occurrence-indexed predicate.
        :return: ``drt.DrtExpression``
        """
        ...



class BoxerOutputDrsParser(DrtParser):
    def __init__(self, discourse_id=...) -> None:
        """
        This class is used to parse the Prolog DRS output from Boxer into a
        hierarchy of python objects.
        """
        ...

    def parse(self, data, signature=...): # -> AndExpression | IffExpression | ImpExpression | OrExpression:
        ...

    def get_all_symbols(self): # -> list[str]:
        ...

    def handle(self, tok, context): # -> BoxerDrs | None:
        ...

    def attempt_adjuncts(self, expression, context):
        ...

    def parse_condition(self, indices): # -> list[BoxerNot] | list[BoxerCard | BoxerEq | BoxerNamed | BoxerPred | BoxerProp | BoxerRel | BoxerWhq | Any]:
        """
        Parse a DRS condition

        :return: list of ``DrtExpression``
        """
        ...

    def handle_drs(self, tok): # -> BoxerDrs | None:
        ...

    def handle_condition(self, tok, indices): # -> list[BoxerNot] | list[BoxerCard | BoxerEq | BoxerNamed | BoxerPred | BoxerProp | BoxerRel | BoxerWhq | Any]:
        """
        Handle a DRS condition

        :param indices: list of int
        :return: list of ``DrtExpression``
        """
        ...

    def parse_drs(self): # -> BoxerDrs:
        ...

    def parse_variable(self):
        ...

    def parse_index(self): # -> int:
        ...



class BoxerDrsParser(DrtParser):
    """
    Reparse the str form of subclasses of ``AbstractBoxerDrs``
    """
    def __init__(self, discourse_id=...) -> None:
        ...

    def get_all_symbols(self): # -> list[str]:
        ...

    def attempt_adjuncts(self, expression, context):
        ...

    def handle(self, tok, context):
        ...

    def nullableIntToken(self): # -> int | None:
        ...

    def get_next_token_variable(self, description):
        ...



class AbstractBoxerDrs:
    def variables(self): # -> tuple[set, set, set]:
        """
        :return: (set<variables>, set<events>, set<propositions>)
        """
        ...

    def variable_types(self): # -> dict:
        ...

    def atoms(self): # -> set:
        ...

    def clean(self): # -> Self:
        ...

    def renumber_sentences(self, f): # -> Self:
        ...

    def __hash__(self) -> int:
        ...



class BoxerDrs(AbstractBoxerDrs):
    def __init__(self, refs, conds, consequent=...) -> None:
        ...

    def atoms(self): # -> Any:
        ...

    def clean(self): # -> BoxerDrs:
        ...

    def renumber_sentences(self, f): # -> BoxerDrs:
        ...

    def __repr__(self): # -> str | LiteralString:
        ...

    def __eq__(self, other) -> bool:
        ...

    def __ne__(self, other) -> bool:
        ...

    __hash__ = ...


class BoxerNot(AbstractBoxerDrs):
    def __init__(self, drs) -> None:
        ...

    def atoms(self):
        ...

    def clean(self): # -> BoxerNot:
        ...

    def renumber_sentences(self, f): # -> BoxerNot:
        ...

    def __repr__(self): # -> LiteralString:
        ...

    def __eq__(self, other) -> bool:
        ...

    def __ne__(self, other) -> bool:
        ...

    __hash__ = ...


class BoxerIndexed(AbstractBoxerDrs):
    def __init__(self, discourse_id, sent_index, word_indices) -> None:
        ...

    def atoms(self): # -> set[Self]:
        ...

    def __eq__(self, other) -> bool:
        ...

    def __ne__(self, other) -> bool:
        ...

    __hash__ = ...
    def __repr__(self): # -> str:
        ...



class BoxerPred(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var, name, pos, sense) -> None:
        ...

    def change_var(self, var): # -> BoxerPred:
        ...

    def clean(self): # -> BoxerPred:
        ...

    def renumber_sentences(self, f): # -> BoxerPred:
        ...

    def __iter__(self): # -> Iterator[Any]:
        ...



class BoxerNamed(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var, name, type, sense) -> None:
        ...

    def change_var(self, var): # -> BoxerNamed:
        ...

    def clean(self): # -> BoxerNamed:
        ...

    def renumber_sentences(self, f): # -> BoxerNamed:
        ...

    def __iter__(self): # -> Iterator[Any]:
        ...



class BoxerRel(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var1, var2, rel, sense) -> None:
        ...

    def clean(self): # -> BoxerRel:
        ...

    def renumber_sentences(self, f): # -> BoxerRel:
        ...

    def __iter__(self): # -> Iterator[Any]:
        ...



class BoxerProp(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var, drs) -> None:
        ...

    def referenced_labels(self): # -> set[Any]:
        ...

    def atoms(self):
        ...

    def clean(self): # -> BoxerProp:
        ...

    def renumber_sentences(self, f): # -> BoxerProp:
        ...

    def __iter__(self): # -> Iterator[Any]:
        ...



class BoxerEq(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var1, var2) -> None:
        ...

    def atoms(self): # -> set:
        ...

    def renumber_sentences(self, f): # -> BoxerEq:
        ...

    def __iter__(self): # -> Iterator[Any]:
        ...



class BoxerCard(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, var, value, type) -> None:
        ...

    def renumber_sentences(self, f): # -> BoxerCard:
        ...

    def __iter__(self): # -> Iterator[Any]:
        ...



class BoxerOr(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, drs1, drs2) -> None:
        ...

    def atoms(self):
        ...

    def clean(self): # -> BoxerOr:
        ...

    def renumber_sentences(self, f): # -> BoxerOr:
        ...

    def __iter__(self): # -> Iterator[Any]:
        ...



class BoxerWhq(BoxerIndexed):
    def __init__(self, discourse_id, sent_index, word_indices, ans_types, drs1, variable, drs2) -> None:
        ...

    def atoms(self):
        ...

    def clean(self): # -> BoxerWhq:
        ...

    def renumber_sentences(self, f): # -> BoxerWhq:
        ...

    def __iter__(self): # -> Iterator[LiteralString | Any]:
        ...



class PassthroughBoxerDrsInterpreter:
    def interpret(self, ex):
        ...



class NltkDrtBoxerDrsInterpreter:
    def __init__(self, occur_index=...) -> None:
        ...

    def interpret(self, ex): # -> DRS | DrtNegatedExpression | DrtIndividualVariableExpression | DrtFunctionVariableExpression | DrtEventVariableExpression | DrtConstantExpression | DrtApplicationExpression | DrtProposition | DrtEqualityExpression | DrtOrExpression:
        """
        :param ex: ``AbstractBoxerDrs``
        :return: ``DrtExpression``
        """
        ...



class UnparseableInputException(Exception):
    ...


if __name__ == "__main__":
    opts = ...
    interpreter = ...
    drs = ...
